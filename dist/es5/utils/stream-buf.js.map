{"version":3,"sources":["../../../lib/utils/stream-buf.js"],"names":["Stream","require","PromishLib","utils","StringBuf","StringChunk","data","encoding","_data","_encoding","prototype","length","toBuffer","copy","target","targetOffset","offset","_buffer","Buffer","StringBufChunk","_buf","BufferChunk","ReadWriteBuf","size","buffer","iRead","iWrite","buf","eod","full","read","undefined","write","chunk","Math","min","StreamBuf","module","exports","options","bufSize","buffers","batch","corked","inPos","outPos","pipes","paused","inherits","Duplex","concat","map","rwBuf","_getWritableBuffer","last","push","_pipe","pipe","Promish","resolve","promises","all","then","nop","_writeToBuffers","inLen","callback","Function","shift","process","nextTick","emit","cork","_flush","uncork","end","writeComplete","error","forEach","first","filter","Boolean","setEncoding","pause","resume","isPaused","destination","unpipe","unshift","Error","wrap"],"mappings":"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","file":"stream-buf.js","sourcesContent":["/**\n * Copyright (c) 2015-2017 Guyon Roche\n * LICENCE: MIT - please refer to LICENCE file included with this module\n * or https://github.com/guyonroche/exceljs/blob/master/LICENSE\n */\n\n'use strict';\n\nvar Stream = require('stream');\nvar PromishLib = require('./promish');\n\nvar utils = require('./utils');\nvar StringBuf = require('./string-buf');\n\n\n// =============================================================================\n// data chunks - encapsulating incoming data\nvar StringChunk = function(data, encoding) {\n  this._data = data;\n  this._encoding = encoding;\n};\nStringChunk.prototype = {\n  get length() {\n    return this.toBuffer().length;\n  },\n  // copy to target buffer\n  copy: function(target, targetOffset, offset, length) {\n    return this.toBuffer().copy(target, targetOffset, offset, length);\n  },\n  toBuffer: function() {\n    if (!this._buffer) {\n      this._buffer = new Buffer(this._data, this._encoding);\n    }\n    return this._buffer;\n  }\n};\nvar StringBufChunk = function(data) {\n  this._data = data;\n};\nStringBufChunk.prototype = {\n  get length() {\n    return this._data.length;\n  },\n  // copy to target buffer\n  copy: function(target, targetOffset, offset, length) {\n    // eslint-disable-next-line no-underscore-dangle\n    return this._data._buf.copy(target, targetOffset, offset, length);\n  },\n  toBuffer: function() {\n    return this._data.toBuffer();\n  }\n};\nvar BufferChunk = function(data) {\n  this._data = data;\n};\nBufferChunk.prototype = {\n  get length() {\n    return this._data.length;\n  },\n  // copy to target buffer\n  copy: function(target, targetOffset, offset, length) {\n    this._data.copy(target, targetOffset, offset, length);\n  },\n  toBuffer: function() {\n    return this._data;\n  }\n};\n\n// =============================================================================\n// ReadWriteBuf - a single buffer supporting simple read-write\nvar ReadWriteBuf = function(size) {\n  this.size = size;\n  // the buffer\n  this.buffer = new Buffer(size);\n  // read index\n  this.iRead = 0;\n  // write index\n  this.iWrite = 0;\n};\nReadWriteBuf.prototype = {\n  toBuffer: function() {\n    if ((this.iRead === 0) && (this.iWrite === this.size)) {\n      return this.buffer;\n    }\n\n    var buf = new Buffer(this.iWrite - this.iRead);\n    this.buffer.copy(buf, 0, this.iRead, this.iWrite);\n    return buf;\n  },\n  get length() {\n    return this.iWrite - this.iRead;\n  },\n  get eod() {\n    return this.iRead === this.iWrite;\n  },\n  get full() {\n    return this.iWrite === this.size;\n  },\n  read: function(size) {\n    var buf;\n    // read size bytes from buffer and return buffer\n    if (size === 0) {\n      // special case - return null if no data requested\n      return null;\n    }\n\n    if ((size === undefined) || (size >= this.length)) {\n      // if no size specified or size is at least what we have then return all of the bytes\n      buf = this.toBuffer();\n      this.iRead = this.iWrite;\n      return buf;\n    }\n\n    // otherwise return a chunk\n    buf = new Buffer(size);\n    this.buffer.copy(buf, 0, this.iRead, size);\n    this.iRead += size;\n    return buf;\n  },\n  write: function(chunk, offset, length) {\n    // write as many bytes from data from optional source offset\n    // and return number of bytes written\n    var size = Math.min(length, this.size - this.iWrite);\n    chunk.copy(this.buffer, this.iWrite, offset, offset + size);\n    this.iWrite += size;\n    return size;\n  }\n};\n\n// =============================================================================\n// StreamBuf - a multi-purpose read-write stream\n//  As MemBuf - write as much data as you like. Then call toBuffer() to consolidate\n//  As StreamHub - pipe to multiple writables\n//  As readable stream - feed data into the writable part and have some other code read from it.\nvar StreamBuf = module.exports = function(options) {\n  options = options || {};\n  this.bufSize = options.bufSize || 1024 * 1024;\n  this.buffers = [];\n\n  // batch mode fills a buffer completely before passing the data on\n  // to pipes or 'readable' event listeners\n  this.batch = options.batch || false;\n\n  this.corked = false;\n  // where in the current writable buffer we're up to\n  this.inPos = 0;\n\n  // where in the current readable buffer we've read up to\n  this.outPos = 0;\n\n  // consuming pipe streams go here\n  this.pipes = [];\n\n  // controls emit('data')\n  this.paused = false;\n\n  this.encoding = null;\n};\n\nutils.inherits(StreamBuf, Stream.Duplex, {\n\n  toBuffer: function() {\n    switch (this.buffers.length) {\n      case 0:\n        return null;\n      case 1:\n        return this.buffers[0].toBuffer();\n      default:\n        return Buffer.concat(this.buffers.map(function(rwBuf) { return rwBuf.toBuffer(); }));\n    }\n  },\n\n  // writable\n  // event drain - if write returns false (which it won't), indicates when safe to write again.\n  // finish - end() has been called\n  // pipe(src) - pipe() has been called on readable\n  // unpipe(src) - unpipe() has been called on readable\n  // error - duh\n\n  _getWritableBuffer: function() {\n    if (this.buffers.length) {\n      var last = this.buffers[this.buffers.length - 1];\n      if (!last.full) {\n        return last;\n      }\n    }\n    var buf = new ReadWriteBuf(this.bufSize);\n    this.buffers.push(buf);\n    return buf;\n  },\n\n  _pipe: function(chunk) {\n    var write = function(pipe) {\n      return new PromishLib.Promish(function(resolve) {\n        pipe.write(chunk.toBuffer(), function() {\n          resolve();\n        });\n      });\n    };\n    var promises = this.pipes.map(write);\n    return promises.length ?\n      PromishLib.Promish.all(promises).then(utils.nop) :\n      PromishLib.Promish.resolve();\n  },\n  _writeToBuffers: function(chunk) {\n    var inPos = 0;\n    var inLen = chunk.length;\n    while (inPos < inLen) {\n      // find writable buffer\n      var buffer = this._getWritableBuffer();\n\n      // write some data\n      inPos += buffer.write(chunk, inPos, inLen - inPos);\n    }\n  },\n  write: function(data, encoding, callback) {\n    if (encoding instanceof Function) {\n      callback = encoding;\n      encoding = 'utf8';\n    }\n    callback = callback || utils.nop;\n\n    // encapsulate data into a chunk\n    var chunk;\n    if (data instanceof StringBuf) {\n      chunk = new StringBufChunk(data);\n    } else if (data instanceof Buffer) {\n      chunk = new BufferChunk(data);\n    } else {\n      // assume string\n      chunk = new StringChunk(data, encoding);\n    }\n\n    // now, do something with the chunk\n    if (this.pipes.length) {\n      if (this.batch) {\n        this._writeToBuffers(chunk);\n        while (!this.corked && (this.buffers.length > 1)) {\n          this._pipe(this.buffers.shift());\n        }\n      } else if (!this.corked) {\n        this._pipe(chunk).then(callback);\n      } else {\n        this._writeToBuffers(chunk);\n        process.nextTick(callback);\n      }\n    } else {\n      if (!this.paused) {\n        this.emit('data', chunk.toBuffer());\n      }\n\n      this._writeToBuffers(chunk);\n      this.emit('readable');\n    }\n\n    return true;\n  },\n  cork: function() {\n    this.corked = true;\n  },\n  _flush: function(/* destination */) {\n    // if we have comsumers...\n    if (this.pipes.length) {\n      // and there's stuff not written\n      while (this.buffers.length) {\n        this._pipe(this.buffers.shift());\n      }\n    }\n  },\n  uncork: function() {\n    this.corked = false;\n    this._flush();\n  },\n  end: function(chunk, encoding, callback) {\n    var writeComplete = error => {\n      if (error) {\n        callback(error);\n      } else {\n        this._flush();\n        this.pipes.forEach(pipe => { pipe.end(); });\n        this.emit('finish');\n      }\n    };\n    if (chunk) {\n      this.write(chunk, encoding, writeComplete);\n    } else {\n      writeComplete();\n    }\n  },\n\n  // readable\n  // event readable - some data is now available\n  // event data - switch to flowing mode - feeds chunks to handler\n  // event end - no more data\n  // event close - optional, indicates upstream close\n  // event error - duh\n  read: function(size) {\n    var buffers;\n    // read min(buffer, size || infinity)\n    if (size) {\n      buffers = [];\n      while (size && this.buffers.length && !this.buffers[0].eod) {\n        var first = this.buffers[0];\n        var buffer = first.read(size);\n        size -= buffer.length;\n        buffers.push(buffer);\n        if (first.eod && first.full) {\n          this.buffers.shift();\n        }\n      }\n      return Buffer.concat(buffers);\n    }\n\n    buffers = this.buffers.map(buf => buf.toBuffer())\n      .filter(Boolean);\n    this.buffers = [];\n    return Buffer.concat(buffers);\n  },\n  setEncoding: function(encoding) {\n    // causes stream.read or stream.on('data) to return strings of encoding instead of Buffer objects\n    this.encoding = encoding;\n  },\n  pause: function() {\n    this.paused = true;\n  },\n  resume: function() {\n    this.paused = false;\n  },\n  isPaused: function() {\n    return !!this.paused;\n  },\n  pipe: function(destination) {\n    // add destination to pipe list & write current buffer\n    this.pipes.push(destination);\n    if (!this.paused && this.buffers.length) {\n      this.end();\n    }\n  },\n  unpipe: function(destination) {\n    // remove destination from pipe list\n    this.pipes = this.pipes.filter(function(pipe) {\n      return pipe !== destination;\n    });\n  },\n  unshift: function(/* chunk */) {\n    // some numpty has read some data that's not for them and they want to put it back!\n    // Might implement this some day\n    throw new Error('Not Implemented');\n  },\n  wrap: function(/* stream */) {\n    // not implemented\n    throw new Error('Not Implemented');\n  }\n});\n"]}