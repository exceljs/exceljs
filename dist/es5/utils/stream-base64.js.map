{"version":3,"sources":["../../../lib/utils/stream-base64.js"],"names":["Stream","require","utils","StreamBuf","module","exports","pipes","inherits","Duplex","write","cork","uncork","end","read","setEncoding","encoding","pause","resume","isPaused","pipe","destination","push","unpipe","filter","unshift","Error","wrap"],"mappings":"AAAA;;AAEA,IAAIA,SAASC,QAAQ,QAAR,CAAb;AACA,IAAIC,QAAQD,QAAQ,SAAR,CAAZ;;AAEA;AACA;AACA;AACA,IAAIE,YAAYC,OAAOC,OAAP,GAAiB,YAAW;AAC1C;AACA,OAAKC,KAAL,GAAa,EAAb;AACD,CAHD;;AAKAJ,MAAMK,QAAN,CAAeJ,SAAf,EAA0BH,OAAOQ,MAAjC,EAAyC;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEAC,SAAO,iBAAS,oBAAsB;AACpC,WAAO,IAAP;AACD,GAVsC;AAWvCC,QAAM,gBAAW,CAChB,CAZsC;AAavCC,UAAQ,kBAAW,CAClB,CAdsC;AAevCC,OAAK,eAAS,+BAAiC,CAC9C,CAhBsC;;AAkBvC;AACA;AACA;AACA;AACA;AACA;AACAC,QAAM,gBAAS,UAAY,CAC1B,CAzBsC;AA0BvCC,eAAa,qBAASC,QAAT,EAAmB;AAC9B;AACA,SAAKA,QAAL,GAAgBA,QAAhB;AACD,GA7BsC;AA8BvCC,SAAO,iBAAW,CACjB,CA/BsC;AAgCvCC,UAAQ,kBAAW,CAClB,CAjCsC;AAkCvCC,YAAU,oBAAW,CACpB,CAnCsC;AAoCvCC,QAAM,cAASC,WAAT,EAAsB;AAC1B;AACA,SAAKd,KAAL,CAAWe,IAAX,CAAgBD,WAAhB;AACD,GAvCsC;AAwCvCE,UAAQ,gBAASF,WAAT,EAAsB;AAC5B;AACA,SAAKd,KAAL,GAAa,KAAKA,KAAL,CAAWiB,MAAX,CAAkB,UAASJ,IAAT,EAAe;AAC5C,aAAOA,SAASC,WAAhB;AACD,KAFY,CAAb;AAGD,GA7CsC;AA8CvCI,WAAS,mBAAS,WAAa;AAC7B;AACA;AACA,UAAM,IAAIC,KAAJ,CAAU,iBAAV,CAAN;AACD,GAlDsC;AAmDvCC,QAAM,gBAAS,YAAc;AAC3B;AACA,UAAM,IAAID,KAAJ,CAAU,iBAAV,CAAN;AACD;AAtDsC,CAAzC","file":"stream-base64.js","sourcesContent":["'use strict';\n\nvar Stream = require('stream');\nvar utils = require('./utils');\n\n// =============================================================================\n// StreamBase64 - A utility to convert to/from base64 stream\n// Note: does not buffer data, must be piped\nvar StreamBuf = module.exports = function() {\n  // consuming pipe streams go here\n  this.pipes = [];\n};\n\nutils.inherits(StreamBuf, Stream.Duplex, {\n  // writable\n  // event drain - if write returns false (which it won't), indicates when safe to write again.\n  // finish - end() has been called\n  // pipe(src) - pipe() has been called on readable\n  // unpipe(src) - unpipe() has been called on readable\n  // error - duh\n\n  write: function(/* data, encoding */) {\n    return true;\n  },\n  cork: function() {\n  },\n  uncork: function() {\n  },\n  end: function(/* chunk, encoding, callback */) {\n  },\n\n  // readable\n  // event readable - some data is now available\n  // event data - switch to flowing mode - feeds chunks to handler\n  // event end - no more data\n  // event close - optional, indicates upstream close\n  // event error - duh\n  read: function(/* size */) {\n  },\n  setEncoding: function(encoding) {\n    // causes stream.read or stream.on('data) to return strings of encoding instead of Buffer objects\n    this.encoding = encoding;\n  },\n  pause: function() {\n  },\n  resume: function() {\n  },\n  isPaused: function() {\n  },\n  pipe: function(destination) {\n    // add destination to pipe list & write current buffer\n    this.pipes.push(destination);\n  },\n  unpipe: function(destination) {\n    // remove destination from pipe list\n    this.pipes = this.pipes.filter(function(pipe) {\n      return pipe !== destination;\n    });\n  },\n  unshift: function(/* chunk */) {\n    // some numpty has read some data that's not for them and they want to put it back!\n    // Might implement this some day\n    throw new Error('Not Implemented');\n  },\n  wrap: function(/* stream */) {\n    // not implemented\n    throw new Error('Not Implemented');\n  }\n});\n"]}