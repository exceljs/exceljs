{"version":3,"sources":["../../../lib/csv/line-buffer.js"],"names":["events","require","utils","LineBuffer","module","exports","options","EventEmitter","call","encoding","buffer","corked","queue","inherits","write","chunk","data","lines","split","pop","forEach","line","push","emit","cork","uncork","_flush","setDefaultEncoding","end"],"mappings":"AAAA;;;;;;AAMA;;AAEA,IAAIA,SAASC,QAAQ,QAAR,CAAb;;AAEA,IAAIC,QAAQD,QAAQ,gBAAR,CAAZ;;AAGA,IAAIE,aAAaC,OAAOC,OAAP,GAAiB,UAASC,OAAT,EAAkB;AAClDN,SAAOO,YAAP,CAAoBC,IAApB,CAAyB,IAAzB;AACA,OAAKC,QAAL,GAAgBH,QAAQG,QAAxB;;AAEA,OAAKC,MAAL,GAAc,IAAd;;AAEA;AACA,OAAKC,MAAL,GAAc,KAAd;AACA,OAAKC,KAAL,GAAa,EAAb;AACD,CATD;;AAWAV,MAAMW,QAAN,CAAeV,UAAf,EAA2BH,OAAOO,YAAlC,EAAgD;AAC9C;AACA;AACA;;AAEAO,SAAO,eAASC,KAAT,EAAgB;AACrB;AACA;AACA,QAAIC,OAAO,KAAKN,MAAL,GAAc,KAAKA,MAAL,GAAcK,KAA5B,GAAoCA,KAA/C;AACA,QAAIE,QAAQD,KAAKE,KAAL,CAAW,QAAX,CAAZ;;AAEA;AACA,SAAKR,MAAL,GAAcO,MAAME,GAAN,EAAd;;AAEAF,UAAMG,OAAN,CAAc,UAASC,IAAT,EAAe;AAC3B,UAAI,KAAKV,MAAT,EAAiB;AACf,aAAKC,KAAL,CAAWU,IAAX,CAAgBD,IAAhB;AACD,OAFD,MAEO;AACL,aAAKE,IAAL,CAAU,MAAV,EAAkBF,IAAlB;AACD;AACF,KAND;;AAQA,WAAO,CAAC,KAAKV,MAAb;AACD,GAvB6C;AAwB9Ca,QAAM,gBAAW;AACf,SAAKb,MAAL,GAAc,IAAd;AACD,GA1B6C;AA2B9Cc,UAAQ,kBAAW;AACjB,SAAKd,MAAL,GAAc,KAAd;AACA,SAAKe,MAAL;;AAEA;AACA,SAAKH,IAAL,CAAU,OAAV;AACD,GAjC6C;AAkC9CI,sBAAoB,8BAAW;AAC7B;AACD,GApC6C;AAqC9CC,OAAK,eAAW;AACd,QAAI,KAAKlB,MAAT,EAAiB;AACf,WAAKa,IAAL,CAAU,MAAV,EAAkB,KAAKb,MAAvB;AACA,WAAKA,MAAL,GAAc,IAAd;AACD;AACD,SAAKa,IAAL,CAAU,MAAV;AACD,GA3C6C;;AA6C9CG,UAAQ,kBAAW;AACjB,QAAI,CAAC,KAAKf,MAAV,EAAkB;AAChB,WAAKC,KAAL,CAAWQ,OAAX,CAAmB,UAASC,IAAT,EAAe;AAChC,aAAKE,IAAL,CAAU,MAAV,EAAkBF,IAAlB;AACD,OAFD;AAGA,WAAKT,KAAL,GAAa,EAAb;AACD;AACF;AApD6C,CAAhD","file":"line-buffer.js","sourcesContent":["/**\n * Copyright (c) 2015-2017 Guyon Roche\n * LICENCE: MIT - please refer to LICENCE file included with this module\n * or https://github.com/guyonroche/exceljs/blob/master/LICENSE\n */\n\n'use strict';\n\nvar events = require('events');\n\nvar utils = require('../utils/utils');\n\n\nvar LineBuffer = module.exports = function(options) {\n  events.EventEmitter.call(this);\n  this.encoding = options.encoding;\n\n  this.buffer = null;\n\n  // part of cork/uncork\n  this.corked = false;\n  this.queue = [];\n};\n\nutils.inherits(LineBuffer, events.EventEmitter, {\n  // Events:\n  //  line: here is a line\n  //  done: all lines emitted\n\n  write: function(chunk) {\n    // find line or lines in chunk and emit them if not corked\n    // or queue them if corked\n    var data = this.buffer ? this.buffer + chunk : chunk;\n    var lines = data.split(/\\r?\\n/g);\n\n    // save the last line\n    this.buffer = lines.pop();\n\n    lines.forEach(function(line) {\n      if (this.corked) {\n        this.queue.push(line);\n      } else {\n        this.emit('line', line);\n      }\n    });\n\n    return !this.corked;\n  },\n  cork: function() {\n    this.corked = true;\n  },\n  uncork: function() {\n    this.corked = false;\n    this._flush();\n\n    // tell the source I'm ready again\n    this.emit('drain');\n  },\n  setDefaultEncoding: function() {\n    // ?\n  },\n  end: function() {\n    if (this.buffer) {\n      this.emit('line', this.buffer);\n      this.buffer = null;\n    }\n    this.emit('done');\n  },\n\n  _flush: function() {\n    if (!this.corked) {\n      this.queue.forEach(function(line) {\n        this.emit('line', line);\n      });\n      this.queue = [];\n    }\n  }\n});\n"]}